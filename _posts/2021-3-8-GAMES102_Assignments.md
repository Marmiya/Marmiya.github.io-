---
layout: post
title: GAMES-102 Assignment
subtitle: CODE
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: [code]
---

## Assignment 1

[Original details](/assets/games_102_assignment/assignment1.md)

**Note 1**: The method I had used in my code is motivated by  Xueyuan Yang.

**Note 2**: Although you can use other framework to finish this assignment, I strongly recommend you try to use utopia(the framework developed by USTC), it's small and easy to learn, the best of it is interaction.

My CanvasData.h was changed like below:

```c++
struct CanvasData {
	std::vector<Ubpa::pointf2> points;
	Ubpa::valf2 scrolling{ 0.f,0.f };
	bool opt_enable_grid{ true };
	bool opt_enable_context_menu{ true };
	bool adding_line{ false };

	bool hadInputDone{ false };//Onceaftering inputting all points, check this, 		which will recalculate the interpolation points.
	bool Polynomial{ false };
	bool Gauss{ false };
	bool LSM{ false };
	bool RR{ false };


	float step_length = 1.0;
	float lambda = 50.0;
	std::vector<double> IntpltnPts;
	std::vector<double> PolynomialY;
	std::vector<double> GaussY;
	std::vector<double> LSMY;
	std::vector<double> RRY;
};
```



### 1. Interpolation fitting

* Polynomial function as basis function:

  The algorithm is Lagrange interpolation algorithm.

  ```c++
  std::vector<double> Polynomial(std::vector<double> ip, CanvasData* data) {
  	std::vector<double> v;
  	for (const double p : ip) {
  		double y = 0.0;
  		for (int m = 0; m < data->points.size(); m++) {
  			double l = data->points[m][1];
  			for (int o = 0; o < data->points.size(); o++) {
  				if (m != o) {
  					l *= (p - data->points[o][0]) / (data->points[m][0] -                              data->points[o][0]);
  				}
  			}
  			y += l;
  		}
  		v.push_back(y);
  	}
  	return v;
  }
  ```

* Gauss Basis Function

  ```c++
  std::vector<double> Gauss(std::vector<double> ip, CanvasData* data) {
  	size_t dataSize = data->points.size();
  	VectorXd y(dataSize + 1);
  	MatrixXd x(dataSize + 1, dataSize + 1);
  	x.setOnes();
  	VectorXd b(dataSize + 1);
  	
  	double lmb_sq = 1 / (pow(data->lambda, 2));
  	for (size_t row = 0; row < dataSize; row++) {
  		y(row) = data->points[row][1];
  		for (size_t col = 1; col <= dataSize; col++) {
  			x(row, col) = exp(-0.5 * pow(data->points[row][0] - data->points[col-1][0], 2) * lmb_sq);
  		}
  	}
  	y(dataSize) = (data->points[dataSize - 1][1] + data->points[dataSize - 2][1]) / 2;
  	for (size_t col = 1; col <= dataSize; col++) 
  		x(dataSize, col) = exp(-0.5 * pow((data->points[dataSize - 1][0] + data->points[dataSize - 2][0]) / 2 - data->points[col-1][0], 2) * lmb_sq);
  	
  	b = x.colPivHouseholderQr().solve(y);
  	std::vector<double> v;
  	for (const double p : ip) {
  		double py = b(0);
  		for (size_t ts = 1; ts <= dataSize; ts++) {
  			py += b(ts) * exp(-0.5 * pow(p - data->points[ts-1][0], 2) * lmb_sq);
  		}
  		v.push_back(py);
  	}
  	return v;
  }
  ```

* LSM:

  ```c++
  std::vector<double> LSM(std::vector<double> ip, CanvasData* data) {
  	std::vector<double> v;
  
  	size_t dataSize = data->points.size();
  	size_t m = 10;
  	if (m >= dataSize) m = dataSize - 3;
  
  	VectorXd y(dataSize);
  	VectorXd a(m + 1);
  	MatrixXd b(dataSize, m + 1);
  
  	for (size_t row = 0; row < dataSize; row++) {
  		for (size_t col = 0; col <= m; col++) {
  			b(row, col) = pow(data->points[row][0], col);
  		}
  		y(row) = data->points[row][1];
  	}
  
  	a = (b.transpose() * b).inverse() * (b.transpose() * y);
  	
  	for (const float p : ip) {
  		double y = 0.0;
  		for (int i = 0; i <= m; i++) {
  			y += pow(p, i) * a(i);
  		}
  		v.push_back(y);
  	}
  	return v;
  }
  
  ```

* RR:

  ```c++
  std::vector<double> RR(std::vector<double> ip, CanvasData* data, float lambda) {
  	std::vector<double> v;
  
  	size_t dataSize = data->points.size();
  	size_t m = 10;
  	if (m >= dataSize) m = dataSize - 3;
  
  	VectorXd y(dataSize);
  	VectorXd a(m + 1);
  	MatrixXd b(dataSize, m + 1);
  
  	for (size_t row = 0; row < dataSize; row++) {
  		for (size_t col = 0; col <= m; col++) {
  			b(row, col) = pow(data->points[row][0], col);
  		}
  		y(row) = data->points[row][1];
  	}
  
  	a = (b.transpose() * b + lambda * MatrixXd::Identity(m + 1, m + 1)).inverse() * (b.transpose() * y);
  
  	for (const float p : ip) {
  		double y = 0.0;
  		for (int i = 0; i <= m; i++) {
  			y += pow(p, i) * a(i);
  		}
  		v.push_back(y);
  	}
  	return v;
  }
  ```


**Result:**

![RESULT](/assets/img/assignment101.png)

We can find easily that the curve generated by polynomial interpolation heavily shock when polynomial's power is large.

Gauss interpolation sometimes is good but you should redefine the $$\sigma$$ every time.

LSM and RR is better than interpolation method in some way, meanwhile RR is better than LSM.

## Assignment 2 Function Fitting by RBF

[Original details](/assets/games_102_assignment/assignment2.md)

I finish this assignment by **pytorch**.

1. I random draft a function:
   $$
   f=x^3+e^{-x}+5\ (-5<x<5)
   $$
   ![Function Curve](/assets/img/assignment201.png)

2. Sampling some points on the curve of this function.

3. Define my RBF function:

   ```python
   class NRBF(nn.Module):
       def __init__(self):
           super().__init__()
       def forward(self,input):
           for i in range(input.size()[0]):
               input[i] = math.exp(-0.5 * pow(input[i],2))
           return input
   ```

4. Define model:

   ```python
   model = nn.Sequential(collections.OrderedDict([
       ('fc1',nn.Linear(2,150)),
       ('activation',activation_function),
       ('fc2',nn.Linear(150,1))
   ]))
   ```

5. Train model and draw line:

   ![Result](\assets\img\assignment202.png)

**Result:**

The curve My function generated has a little shock, which may be caused by the parameters or this basis function span is not fit to the function I drafted. 

## Assignment 3 Use Single Parameter Curve to fit Random Dot column

[Original details](/assets/ass/games_102_assignment/assignment3.md)

I finish it by **pytorch**

1. I choose the parameter form of **Cardioid Curve** with $$a=1$$. 
   $$
   \begin{cases}
   x(t)=2cos(t)-cos(2t)\\
   t(t)=2sin(t)-sin(2t)
   \end{cases}
   $$

2. In order to overlap, I intercept $$t$$ in range $$(-3,2)$$.

   ```python
   def heartX(t):
       return 2 * math.cos(t) - math.cos(2 * t)
   def heartY(t):
       return 2 * math.sin(t) - math.sin(2 * t)
   ```

   

3. Generate some points to simulate sampling.

   ```python
   pointsNumber = 80
   samlpeT = np.array(sorted(np.random.rand(pointsNumber) * 5 - 3))
   samlpeX = torch.from_numpy(fromiterHeartX(samlpeT)).type(torch.FloatTensor)
   samlpeY = torch.from_numpy(fromiterHeartY(samlpeT)).type(torch.FloatTensor)
   ```

4. Then we should use several parameterization methods in lesson.

   here I use **Chord Parameterization** as example:

   ```python
   total = 0.0
   CT = []
   lent = 0.0
   for i in range(pointsNumber):
       total += math.sqrt(math.pow(samlpeX[i], 2) + math.pow(samlpeY[i], 2))
   for i in range(pointsNumber):
       CT.append(lent)
       lent += math.sqrt(math.pow(samlpeX[i], 2) + math.pow(samlpeY[i], 2)) / total
   CNT = np.array(CT)
   CNTT = torch.from_numpy(CNT).type(torch.FloatTensor).resize_(pointsNumber, 1)
   ```

5. Then we define two model for $$x$$ and $$y$$, respectively, and train them (just like normal neural network model ).

   ```python
   modelX = nn.Sequential(collections.OrderedDict([
       ('fc1',nn.Linear(1, fc1Number)),
       ('af1',nn.Sigmoid()),
       ('fc2',nn.Linear(fc1Number, fc2Number)),
       ('af2',nn.Sigmoid()),
       ('fc3',nn.Linear(fc2Number, 1))
   ]))
   ```

   ```python
   def SQLoss(outputX, outputY, targetX, targetY):
       los = torch.sum( torch.sqrt(torch.pow(outputX - targetX, 2) + torch.pow(outputY - targetY, 2)) )
       return los
   ```

   

   ```python
   learningRate = 0.03
   criterionS = SQLoss
   optimizerX = torch.optim.Adam(modelX.parameters(), lr = learningRate)
   optimizerY = torch.optim.Adam(modelY.parameters(), lr = learningRate)
   epochs = 10000
       
   for i in range(epochs):
       xPred = modelX(CNTT)
       yPred = modelY(CNTT)
       
       xPred = xPred.squeeze()
       yPred = yPred.squeeze()
       
       loss = criterionS(xPred, yPred, samlpeX, samlpeY)
           
       optimizerX.zero_grad()
       optimizerY.zero_grad()
           
       loss.backward()
       
       optimizerX.step()
       optimizerY.step()
   ```

   

**RESULT:**

![](/assets/img/ass3.png)

## Assignment 4

[original details](/assets/games_102_assignment/assignment4.md)

1. I configure it in Utopia.

2. The core of this assignment is configure that cubic spline curve.

   The critical matrix is:

   
   $$
   \left[
   \begin{matrix}
   u1&h1\\
   h1&u2&h2\\
    & h2&u3&h3\\
    &&\ddots&\ddots&\ddots\\
    &&&h_{n-3}&u_{n-2}&h_{n-2}\\
    &&&&h_{n-2}&u_{n-1}
    
   \end{matrix}
   \right]
   \left[
   \begin{matrix}
   M_1\\
   M_2\\
   M_3\\
   \vdots\\
   M_{n-2}\\
   M_{n-1}
   \end{matrix}
   \right]
   =\left[
   \begin{matrix}
   v_1\\
   v_2\\
   v_3\\
   \vdots\\
   v_{n-2}\\
   v_{n-1}
   \end{matrix}
   \right]
   $$
   wherein:

   
   $$
   h_i=x_{i+1}-x_i\\
   v_i=2(h_i+h_{i-1})\\
   b_i=\frac{6}{h_i}(y_{i+1}-y_i)\\
   v_i=b_i-b_{i-1}
   $$
   

   3. Then we need solve the matrix **M**

   4. At last:

      
      $$
      S_i(x)=\frac{M_i}{6h_i}(x_{i+1}-x)^3+\frac{M_{i+1}}{6h_i}(x-x_i)^3
      +(\frac{y_{i+1}}{h_i}-\frac{M_{i+1}h_i}{6})(x-x_i)+
      (\frac{y_{i}}{h_i}-\frac{M_{i}h_i}{6})(x_{i+1}-x)
      $$
      

   OK, Result:

   ![RESULT](/assets/img/cubicspline.png)

## Assignment 5

[Original details](/assets/games_102_assignment/assignment5.md)

I finish this assignment by Utopia.

This assignment is quite basically. We just need configure its algorithm.

For Chaykin:

Quadric:

```c++
std::vector<ImVec2> quadraticChaykin(CanvasData* data) {
	std::vector<ImVec2> v;
	size_t size = data->points.size();
	for (const auto i : data->points) {
		v.push_back(i);
	}
	for (int i = 0; i < 10; i++) {
		std::vector<ImVec2> vt;
		size_t vSize = v.size();
		for (int j = 0; j < vSize - 1; j++) {
			
			vt.push_back(ImVec2((0.75 * v[j][0] + 0.25 * v[j + 1][0]), (0.75 * v[j][1] + 0.25 * v[j + 1][1])));
			vt.push_back(ImVec2((0.25 * v[j][0] + 0.75 * v[j + 1][0]), (0.25 * v[j][1] + 0.75 * v[j + 1][1])));
		}
		
		vt.push_back(ImVec2((0.75 * v[vSize - 1][0] + 0.25 * v[0][0]), (0.75 * v[vSize - 1][1] + 0.25 * v[0][1])));
		vt.push_back(ImVec2((0.25 * v[vSize - 1][0] + 0.75 * v[0][0]), (0.25 * v[vSize - 1][1] + 0.75 * v[0][1])));

		v.clear();
		for (const auto i : vt) {
			v.push_back(i);
		}
	}
	return v;
}
```

 Cubic

```c++
std::vector<ImVec2> cubicChaykin(CanvasData* data) {
	std::vector<ImVec2> v;
	size_t size = data->points.size();
	for (const auto i : data->points) {
		v.push_back(i);
	}
	for (int i = 0; i < 10; i++) {
		std::vector<ImVec2> vt;
		size_t vSize = v.size();
		for (int j = 1; j < vSize - 1; j++) {
			vt.push_back(ImVec2((0.125 * v[j - 1][0] + 0.75 * v[j][0] + 0.125 * v[j + 1][0]), (0.125 * v[j - 1][1] + 0.75 * v[j][1] + 0.125 * v[j + 1][1])));
			vt.push_back(ImVec2((0.5 * v[j][0] + 0.5 * v[j + 1][0]), (0.5 * v[j][1] + 0.5 * v[j + 1][1])));
		}
		vt.push_back(ImVec2((0.125 * v[vSize - 2][0] + 0.75 * v[vSize - 1][0] + 0.125 * v[0][0]), (0.125 * v[vSize - 2][1] + 0.75 * v[vSize - 1][1] + 0.125 * v[0][1])));
		vt.push_back(ImVec2((0.5 * v[vSize - 1][0] + 0.5 * v[0][0]), (0.5 * v[vSize - 1][1] + 0.5 * v[0][1])));
		vt.push_back(ImVec2((0.125 * v[vSize - 1][0] + 0.75 * v[0][0] + 0.125 * v[1][0]), (0.125 * v[vSize - 1][1] + 0.75 * v[0][1] + 0.125 * v[1][1])));
		vt.push_back(ImVec2((0.5 * v[1][0] + 0.5 * v[0][0]), (0.5 * v[1][1] + 0.5 * v[0][1])));

		v.clear();
		for (const auto i : vt) {
			v.push_back(i);
		}
	}
	return v;
}
```

Four points interpolation subdivision:

```c++
std::vector<ImVec2> FPIS(CanvasData* data) {
	std::vector<ImVec2> v;
	size_t size = data->points.size();
	for (const auto i : data->points) {
		v.push_back(i);
	}
	for (int i = 0; i < 10; i++) {
		std::vector<ImVec2> vt;
		size_t vSize = v.size();
		for (int j = 1; j < vSize - 2; j++) {
			vt.push_back(v[j]);
			vt.push_back(ImVec2(((-0.05) * v[j - 1][0] + 0.55 * v[j][0] + 0.55 * v[j + 1][0] + (-0.05) * v[j + 2][0]), ((-0.05) * v[j - 1][1] + 0.55 * v[j][1] + 0.55 * v[j + 1][1] + (-0.05) * v[j + 2][1])));
		}
		vt.push_back(v[vSize - 2]);
		vt.push_back(ImVec2(((-0.05) * v[vSize - 3][0] + 0.55 * v[vSize - 2][0] + 0.55 * v[vSize - 1][0] + (-0.05) * v[0][0]), ((-0.05) * v[vSize - 3][1] + 0.55 * v[vSize - 2][1] + 0.55 * v[vSize - 1][1] + (-0.05) * v[0][1])));
		vt.push_back(v[vSize - 1]);
		vt.push_back(ImVec2(((-0.05) * v[vSize - 2][0] + 0.55 * v[vSize - 1][0] + 0.55 * v[0][0] + (-0.05) * v[1][0]), ((-0.05) * v[vSize - 2][1] + 0.55 * v[vSize - 1][1] + 0.55 * v[0][1] + (-0.05) * v[1][1])));
		vt.push_back(v[0]);
		vt.push_back(ImVec2(((-0.05) * v[vSize - 1][0] + 0.55 * v[0][0] + 0.55 * v[1][0] + (-0.05) * v[2][0]), ((-0.05) * v[vSize - 1][1] + 0.55 * v[0][1] + 0.55 * v[1][1] + (-0.05) * v[2][1])));
		v.clear();
		for (const auto i : vt) {
			v.push_back(i);
		}
	}
		
	return v;
}
```

**Result**

![](/assets/img/assignment5.png)
